# 01 快慢指针技巧
1. 【删除有序数组的重复项】重要
> fast 每回合都++，slow 不相同时++
> 先 slow ++ ，返回 slow + 1

2. 【移除元素】 1 变
>改判断条件为 == val
> 后 slow ++, 返回 val

3. 【移动0】1变
> 复用 2， val =0，然后 末尾赋值为0

# 02 左右指针
1. 二分查找 【二分查找】
> 向中间靠拢
2. 两数之和 【两数之和-ii, 有序树组】
> 1. 也是左右指针，和二分法类似，但是 难以推导
> 2. 条件： 变为 sum 
> 3. 递增变成 left ++, right ++ 
3. 【反转字符串】
> 头尾交换
4. 【寻找回文字符串】
> 1. 从中间，向两头开始找。 分为奇数单数
> 2. 遍历 比大小

# 03 前缀和数组
1. 前缀和 ，提前计算从和，利用减法，减去暴力 遍历 【区域和检索 - 数组不可变】
> presum[i] = presum[i-1] + num[i-1], i=1...k
> presum[i...j] = presum[i+1]-presum[left]

2. 【区域和检索 - 矩阵不可变】
# 04 差分数组技巧
小众

# 05 花式遍历
1. 【颠倒字符串中的单词】原地旋转单词，先整体翻转，再每个单词翻转
2. 【旋转图像】 先对称旋转，在逐行翻转。 注意 翻转时，二层遍历 不要全部遍遍历

# 06 滑动窗口问题
解决子串问题
1. [最小覆盖子串] 
> 先确定终点：right 一直会 ++， 一直到 0 ~ right 刚好包含所有的 数字， vaild = need.size()
> 增大 left ，确定新起点，一旦vaild 不是新数字。就停止
> right 一直 到 最大，问题结束。
> 收缩条件， valid == need.size()
2. [字符串的排列]
> 收缩 条件 right - left > need.size。确保子串，永远只有排列的长度， 超过长度，就缩短，更新valid

3. [找到字符串中所有字母异位词] 
> 也是找子排列， 但是更近异步，找下表索引
> 和 题目二做法一致， return true ，地方改成 记录索引

4. [无重复字符的最长子串]
> 1. 变种，更简单，滑动窗口的收缩条件： window[c] > 1; 一直收缩到 不大1。
> 记录最长的 索引

# 07 二分查找问题 -- 在有序数组中搜索指定元素
1.[二分查找] 最基本的二分查找
> 边界， right= num.length -1 , 判断条件 left < right
2. [在排序数组中查找元素的第一个和最后一个位置] 
> 进阶： 二分查找是找有没有，这个题是找 左边界和右边界
> 左边界： 当 mid == target 时， right = mid - 1, 边界左移
>> 不存在时： left == num.length , return -1, 
>> 判断 nums[left] == target ，yes 就是 存在, 返回 left
> 右边界： 当 mid == target 时， left = mid + 1, 边界右移
>> 不存在时： left - 1 < 0 , return -1, 
>> 判断 nums[left-1] == target ，yes 就是 存在, 返回 left -1

>  左： right = mid -1; left = length; left
>  右： left = mid + 1; left -1 <0;left -1

3. [按权重随机选择]
> 前缀数组： 累加和
> 求随机数  rand.nextInt(preSum[n - 1]) + 1;
> 求左侧边界: left_bound
>> 1. 能确定 数字一定存在 & 找不大于 target 的索引
>> 所以 直接 return left 即可

# 其他类型
1. [优势洗牌] 田忌赛马，让nums 数组，尽可能多的 nums1[i] >nums2[j]
> 1. 比较复杂 一点，先忽略
2. [常数时间插入、删除和获取随机元素]
> 1. 借助map ，存储时记录索引，
> 2. 删除时，目标值和尾巴值交换，直接删除
3. [字符串去重问题]
> 暴力解： hashset